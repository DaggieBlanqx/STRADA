<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>STRADA documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">STRADA documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>OdPair</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/network/graph.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>An O/D pair is described by the origin and destination nodes, and the type of path.</p>

            </p>


        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#destination">destination</a>
                                </li>
                                <li>
                                        <a href="#origin">origin</a>
                                </li>
                                <li>
                                        <a href="#pathType">pathType</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="destination"></a>
                                        <span class="name"><b>destination</b><a href="#destination"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>destination:     <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="origin"></a>
                                        <span class="name"><b>origin</b><a href="#origin"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>origin:     <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="pathType"></a>
                                        <span class="name"><b>pathType</b><a href="#pathType"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>pathType:     <code><a href="../interfaces/Path.html" target="_self" >PathType</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="../interfaces/Path.html" target="_self" >PathType</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Observable, of, throwError } from &#x27;rxjs&#x27;;

import * as combine from &#x27;mout/array/combine&#x27;;

import { Heap, Path } from &#x27;./k-shortest-path&#x27;;
import { round } from &#x27;../utils&#x27;;
import { environment } from &#x27;../../environments/environment&#x27;;
import { uiConfig } from &#x27;../ui/ui-config&#x27;;

export enum PathType {
    distance &#x3D; &#x27;distance&#x27;,
    duration &#x3D; &#x27;duration&#x27;
}

/**
 * An O/D pair is described by the origin and destination nodes, and the type of path.
 */
export interface OdPair {

    origin: string;
    destination: string;
    pathType: PathType;

}

export interface LinkFlow {

    /**
     * linkFlow attribute.
     */
    value: number;
    /**
     * Variance is the inverse of density.
     */
    variance: number;

}

/**
 * Tag describes the meaning of the particular element to which it is attached.
 */
export interface Tag {

    key: string;
    value: string;

}

/**
 * Relation&#x27;s member.
 */
export interface Member {

    type: string;
    ref: number;
    role: string;

}

/**
 * Node represents a specific point on the earth&#x27;s surface defined by its latitude and longitude.
 */
export class Node {

    public nodeId: number;

    public label: string;

    public lat: number;

    public lon: number;

    public tags: Tag[] &#x3D; [];

    public incomingEdges: Edge[] &#x3D; [];

    public outgoingEdges: Edge[] &#x3D; [];

    public drawingOptions: { marker?: google.maps.Marker } &#x3D; {};

    /**
     * Used by the k shortest path routing.
     */
    public count: number &#x3D; 0;

    constructor(nodeId: number) {
        this.nodeId &#x3D; nodeId;
    }

}

/**
 * Link between two nodes.
 */
export class Edge {

    public edgeId: number;

    public label: string;

    public origin: Node;

    public destination: Node;

    public tags: Tag[] &#x3D; [];

    /**
     * Indicates the distance in meters.
     */
    public distance: number;

    /**
     * Indicates the duration in seconds.
     */
    public duration: number;

    /**
     * Indicates the total duration of the edge, taking into account current traffic conditions.
     */
    public durationInTraffic: number;

    /**
     * Free flow speed (m/s).
     */
    public freeFlowVelocity: number;

    /**
     * Instant speed (m/s).
     */
    public velocity: number;

    public density: number;

    public flow: number;

    /**
     * Number of vehicles calculated from traffic data.
     */
    public linkFlow: number;

    /**
     * Maximum flow of the link.
     */
    public maxFlow: number;

    public drawingOptions: {
        originalPath?: google.maps.LatLng[],
        path?: google.maps.LatLng[],
        polyline?: google.maps.Polyline,
        marker?: google.maps.Marker,
        infowindow?: google.maps.InfoWindow
    } &#x3D; {};

    constructor(edgeId: number) {
        this.edgeId &#x3D; edgeId;
    }

    /**
     * Calculates the value of the link flow.
     */
    public calcLinkFlow(): void {
        // Min distance is 1 meter.
        if (this.distance &#x3D;&#x3D; 0) { this.distance &#x3D; 1; }
        // Min duration is 1 second.
        if (this.duration &#x3D;&#x3D; 0) {
            this.duration &#x3D; round(this.distance / (50 / 3.6)) &gt; 1 ? round(this.distance / (50 / 3.6)) : 1;
        }
        // Calculates free flow velocity (m/s).
        this.freeFlowVelocity &#x3D; round(this.distance / this.duration, 2);
        // Calculates link flow.
        if (this.durationInTraffic &gt; 0 &amp;&amp; this.durationInTraffic &gt;&#x3D; this.duration) {
            // Calculates velocity (m/s).
            this.velocity &#x3D; round(this.distance / this.durationInTraffic, 2);
            // Calculates density.
            this.density &#x3D; round(this.getKjam() * (this.freeFlowVelocity - this.velocity) / this.freeFlowVelocity, 2);
            // Calculates flow.
            this.flow &#x3D; round(this.density * this.velocity, 2);
            // Calculates link flow.
            this.linkFlow &#x3D; round(this.density * this.distance);
        } else {
            this.velocity &#x3D; 0;
            this.density &#x3D; 0;
            this.flow &#x3D; 0;
            this.linkFlow &#x3D; 0;
        }
    }

    /**
     * Calculates the max flow of the edge.
     * @param factor Weather Adjustment Factor
     */
    public calcMaxFlow(factor: number): void {
        const maxFlow &#x3D; this.getKjam() * this.freeFlowVelocity;
        this.maxFlow &#x3D; round(maxFlow * factor, 2);
    }

    /**
     * Gets the variance of measurement error of link flow.
     */
    public getVariance(): number {
        return this.density &gt; 0 ? round(1 / this.density, 2) : 1;
    }

    public getKjam(): number {
        return round(1 / uiConfig.sp, 2);
    }

    protected getCapacity(timeInterval: number): number {
        return this.maxFlow * timeInterval;
    }

    protected draw(color: string, zIndex: number, visible: boolean &#x3D; true): void {
        this.drawingOptions.polyline.set(&#x27;strokeColor&#x27;, color);
        this.drawingOptions.polyline.set(&#x27;zIndex&#x27;, zIndex);
        this.drawingOptions.marker.set(&#x27;visible&#x27;, visible);
    }

}

/**
 * Relation is a multi-purpose data structure that documents a relationship between two or more data elements.
 */
export class Relation {

    public relationId: number;

    public members: Member[];

    public tags: Tag[] &#x3D; [];

    constructor(relationId: number) {
        this.relationId &#x3D; relationId;
    }

}

/**
 * Graph of the transport network.
 */
export class Graph {

    protected nodes: Node[] &#x3D; [];

    protected edges: Edge[] &#x3D; [];

    protected relations: Relation[] &#x3D; [];

    /**
     * Paths for each O/D pair [pairs,paths,edges].
     */
    protected shortestPaths: Edge[][][] &#x3D; [];

    protected incidenceMatrix: boolean[][][] &#x3D; [];

    protected assignmentMatrix: number[][][] &#x3D; [];

    private heap: Heap;

    /**
     * Shortest paths drawing options.
     */
    private drawingOptions: {
        polylines?: google.maps.Polyline[][];
    } &#x3D; {};

    public getNodes(): Node[] {
        return this.nodes;
    }

    public getEdges(): Edge[] {
        return this.edges;
    }

    public getRelations(): Relation[] {
        return this.relations;
    }

    public getNode(nodeId: number): Node | undefined {
        return this.nodes.find((node: Node) &#x3D;&gt; node.nodeId &#x3D;&#x3D; nodeId);
    }

    public addOrUpdateNode(node: Node): void {
        const existingNode &#x3D; this.getNode(node.nodeId);
        if (existingNode) {
            existingNode.incomingEdges &#x3D; combine(existingNode.incomingEdges, node.incomingEdges);
            existingNode.outgoingEdges &#x3D; combine(existingNode.outgoingEdges, node.outgoingEdges);
        } else {
            this.nodes.push(node);
        }
    }

    public getEdge(edgeId: number): Edge {
        return this.edges.find((edge: Edge) &#x3D;&gt; edge.edgeId &#x3D;&#x3D; edgeId);
    }

    public addEdge(edge: Edge): void {
        this.edges.push(edge);
    }

    /**
     * https://wiki.openstreetmap.org/wiki/Key:oneway
     * @param edgeId Id of the edge
     */
    public isOneway(edgeId: number): boolean {
        return !!this.getEdge(edgeId).tags.find(tag &#x3D;&gt; tag.key &#x3D;&#x3D; &#x27;oneway&#x27; &amp;&amp; tag.value !&#x3D; &#x27;no&#x27;) ||
            this.isRoundabout(edgeId);
    }

    /**
     * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout
     * @param edgeId Id of the edge
     */
    public isRoundabout(edgeId: number): boolean {
        return this.getEdge(edgeId).tags.find(tag &#x3D;&gt; tag.key &#x3D;&#x3D; &#x27;junction&#x27; &amp;&amp; tag.value &#x3D;&#x3D; &#x27;roundabout&#x27;) ||
            this.getEdge(edgeId).tags.find(tag &#x3D;&gt; tag.key &#x3D;&#x3D; &#x27;junction&#x27; &amp;&amp; tag.value &#x3D;&#x3D; &#x27;circular&#x27;) ?
            true : false;
    }

    public findOppositeEdge(edge: Edge): Edge {
        return this.edges.find((value: Edge) &#x3D;&gt;
            value.origin.nodeId &#x3D;&#x3D; edge.destination.nodeId &amp;&amp; value.destination.nodeId &#x3D;&#x3D; edge.origin.nodeId
        );
    }

    public getOdNode(label: string): Node {
        return this.nodes.find((node: Node) &#x3D;&gt; node.label &#x3D;&#x3D; label);
    }

    public getOdNodes(): Node[] {
        return this.nodes.filter((node: Node) &#x3D;&gt; node.label);
    }

    /**
     * Calculates the set of minimum paths.
     * @param odPairs The O/D pairs
     */
    public calcShortestPaths(odPairs: OdPair[]): Observable&lt;any&gt; {
        try {
            for (let i &#x3D; 0; i &lt; odPairs.length; i++) {
                const origin &#x3D; this.getOdNode(odPairs[i].origin);
                const destination &#x3D; this.getOdNode(odPairs[i].destination);
                const shortestPaths &#x3D; this.ksp(origin, destination, odPairs[i].pathType, uiConfig.k);
                // Filters the paths.
                this.filterPaths(shortestPaths);
                // Extracts the paths.
                this.shortestPaths[i] &#x3D; [];
                for (const path of shortestPaths) {
                    this.shortestPaths[i].push(path.edges);
                }
            }
            // Draws the paths.
            if (!environment.testing) {
                this.drawPaths();
            }
            // Sets the edges of the paths.
            this.setPathsEdges();

            if (this.getPathsEdges().length &#x3D;&#x3D; 0) {
                return throwError(&#x27;calcShortestPaths&#x27;);
            }
        } catch (error) {
            return throwError(&#x27;calcShortestPaths&#x27;);
        }
        return of(null);
    }

    public getShortestPaths(): Edge[][][] {
        return this.shortestPaths;
    }

    public getPathsEdges(): Edge[] {
        return this.edges.filter((edge: Edge) &#x3D;&gt; edge.label);
    }

    /**
     * Calculates the incidence matrix of paths for O/D pairs.
     */
    public calcIncidenceMatrix(): Observable&lt;any&gt; {
        const edges &#x3D; this.getPathsEdges();
        for (let z &#x3D; 0; z &lt; this.shortestPaths.length; z++) {
            this.incidenceMatrix[z] &#x3D; [];
            for (let n &#x3D; 0; n &lt; this.shortestPaths[z].length; n++) {
                this.incidenceMatrix[z][n] &#x3D; [];
                for (let m &#x3D; 0; m &lt; edges.length; m++) {
                    if (this.shortestPaths[z][n].find(value &#x3D;&gt; value.edgeId &#x3D;&#x3D; edges[m].edgeId)) {
                        // The path crosses the edge.
                        this.incidenceMatrix[z][n][m] &#x3D; true;
                    } else {
                        // The path does not cross the edge.
                        this.incidenceMatrix[z][n][m] &#x3D; false;
                    }
                }
            }
        }
        return of(null);
    }

    public getIncidenceMatrix(): boolean[][][] {
        return this.incidenceMatrix;
    }

    /**
     * Calculates the assignment matrix.
     * @param odPairs The O/D pairs
     */
    public calcAssignmentMatrix(odPairs: OdPair[]): Observable&lt;any&gt; {
        // Calculates the probabilities of shortest paths.
        const shortestPathsProbabilities &#x3D; this.calcShortestPathsProbabilities(odPairs);

        // Assignment matrix.
        for (let z &#x3D; 0; z &lt; this.incidenceMatrix.length; z++) {
            this.assignmentMatrix[z] &#x3D; [];
            for (let n &#x3D; 0; n &lt; this.incidenceMatrix[z].length; n++) {
                this.assignmentMatrix[z][n] &#x3D; [];
                for (let m &#x3D; 0; m &lt; this.incidenceMatrix[z][n].length; m++) {
                    if (this.incidenceMatrix[z][n][m]) {
                        this.assignmentMatrix[z][n][m] &#x3D; shortestPathsProbabilities[z][n];
                    } else {
                        this.assignmentMatrix[z][n][m] &#x3D; 0;
                    }
                }
            }
        }
        return of(null);
    }

    public getAssignmentMatrix(): number[][][] {
        return this.assignmentMatrix;
    }

    /**
     * Gets shortest paths polylines.
     */
    public getPolylines(): google.maps.Polyline[][] {
        return this.drawingOptions.polylines ? this.drawingOptions.polylines : [];
    }

    /**
     * Calculates the max flow for each edge.
     * @param factor Weather Adjustment Factor
     */
    public calcMaxflows(factor: number): Observable&lt;any&gt; {
        const edges &#x3D; this.getPathsEdges();
        for (const edge of edges) {
            edge.calcMaxFlow(factor);
        }
        return of(null);
    }

    /**
     * Calculates the set of minimum paths between a source and destination node based on the link distance or duration attribute.
     * k Shortest Paths algorithm in the Eppstein version.
     * @param o Source node
     * @param d Destination node
     * @param pathType Distance or duration
     * @param k The number of shortest paths to compute
     * @returns The set of shortest paths
     */
    private ksp(o: Node, d: Node, pathType: string, k: number): Path[] {
        // Sets to zero the count property of the nodes.
        this.resetCount();
        // Instantiates the heap.
        this.heap &#x3D; new Heap();
        // Inserts the path of origin into heap with cost 0.
        this.heap.push({ pathId: 0, node: o, edges: [], cost: 0 });
        // Walks the graph.
        return this.walk(o, d, pathType, k);
    }

    /**
     * Breadth First Search (BFS) algorithm for traversing and searching tree data
     * explores the neighbor nodes first, before moving to the next level neighbors.
     */
    private walk(o: Node, d: Node, pathType: string, k: number): Path[] {
        // Set of shortest paths from origin to destination.
        const shortestPaths: Path[] &#x3D; [];

        let pathId &#x3D; 1;
        let node: Node;
        while (this.heap.getPaths().length &gt; 0 &amp;&amp; d.count &lt; k) {
            // Lets nodePath be the shortest cost path in heap by cost.
            const nodePath &#x3D; this.heap.getShortestPath();
            node &#x3D; nodePath.node;
            // Removes the path from the heap.
            this.heap.pop(nodePath.pathId);
            node.count++;

            // The path has been found.
            if (node.nodeId &#x3D;&#x3D; d.nodeId) {
                shortestPaths.push(nodePath);
            }

            if (node.count &lt;&#x3D; k) {
                for (const edge of node.outgoingEdges) {
                    // Checks that the node has not already been crossed.
                    if (this.isValidNode(edge.destination, nodePath)) {
                        const path: Path &#x3D; {
                            pathId: pathId++,
                            node: edge.destination,
                            edges: nodePath.edges.concat([edge]),
                            cost: nodePath.cost + edge[pathType]
                        };
                        this.heap.push(path);
                    }
                }
            }
        }
        return shortestPaths;
    }

    private isValidNode(node: Node, path: Path): boolean {
        return path.edges.find((edge: Edge) &#x3D;&gt; edge.origin.nodeId &#x3D;&#x3D; node.nodeId) ? false : true;
    }

    private resetCount(): void {
        for (const node of this.nodes) {
            node.count &#x3D; 0;
        }
    }

    /**
     * Removes the alternative paths that differ only for two links.
     * @param shortestPaths The shortest paths as created by the algorithm
     */
    private filterPaths(shortestPaths: Path[]): void {
        if (shortestPaths.length &gt; 1) {
            let i &#x3D; 0;
            do {
                const pathA &#x3D; shortestPaths[i].edges;
                const pathB &#x3D; shortestPaths[i + 1].edges;
                const sharedEdges &#x3D; pathA.filter((edgeOfA: Edge) &#x3D;&gt;
                    pathB.find((edgeOfB: Edge) &#x3D;&gt;
                        edgeOfB.edgeId &#x3D;&#x3D; edgeOfA.edgeId));
                if (pathA.length - sharedEdges.length &lt;&#x3D; 1 &amp;&amp; pathB.length - sharedEdges.length &lt;&#x3D; 2) {
                    shortestPaths.splice(i + 1, 1);
                    i &#x3D; 0;
                } else {
                    i++;
                }
            } while (i &lt; shortestPaths.length - 1);
        }
    }

    /**
     * Draws the polyline for each shortest path.
     */
    private drawPaths(): void {
        const lineSymbol &#x3D; {
            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
            scale: 2
        };
        const icons &#x3D; [{
            icon: lineSymbol,
            offset: &#x27;100%&#x27;
        }];
        this.drawingOptions.polylines &#x3D; [];
        for (let z &#x3D; 0; z &lt; this.shortestPaths.length; z++) {
            this.drawingOptions.polylines[z] &#x3D; [];

            for (let n &#x3D; 0; n &lt; this.shortestPaths[z].length; n++) {
                let path: google.maps.LatLng[] &#x3D; [];
                let distance &#x3D; 0;
                let duration &#x3D; 0;
                for (let m &#x3D; 0; m &lt; this.shortestPaths[z][n].length; m++) {
                    const edge &#x3D; this.shortestPaths[z][n][m];
                    path &#x3D; path.concat(edge.drawingOptions.path);
                    distance +&#x3D; edge.distance;
                    duration +&#x3D; edge.duration;
                }
                const polyline &#x3D; new google.maps.Polyline(
                    {
                        path: path,
                        icons: icons,
                        strokeColor: uiConfig.paths.colors[n],
                        strokeOpacity: 1,
                        strokeWeight: 3,
                        zIndex: 10 - n
                    });
                this.drawingOptions.polylines[z][n] &#x3D; polyline;
            }
        }
    }

    private setPathsEdges(): void {
        const edges: Edge[] &#x3D; [];
        let count &#x3D; 1;
        for (const pair of this.shortestPaths) {
            for (const path of pair) {
                for (const edge of path) {
                    if (!edges.find(value &#x3D;&gt; value.edgeId &#x3D;&#x3D; edge.edgeId)) {
                        edges.push(edge);
                        edge.label &#x3D; &#x27;E&#x27; + count++;
                        if (!environment.testing) {
                            edge.drawingOptions.infowindow.setContent(&#x27;Edge: &#x27; + edge.label);
                        }
                    }
                }
            }
        }
    }

    /**
     * Multinomial logit model.
     * @param odPairs The O/D pairs
     */
    private calcShortestPathsProbabilities(odPairs: OdPair[]): number[][] {
        // Gets the total cost of paths.
        const pathCosts &#x3D; this.calcPathCosts(odPairs);
        const shortestPathsProbabilities: number[][] &#x3D; [];
        // Theta parameter adjustment.
        const parameter &#x3D; uiConfig.theta * 100;
        // Calculates numerator.
        const exps: number[][] &#x3D; [];
        for (let z &#x3D; 0; z &lt; pathCosts.length; z++) {
            exps[z] &#x3D; pathCosts[z].map((value: number) &#x3D;&gt; {
                return value &gt; 0 ? Math.exp(-value / parameter) : 0;
            });
        }
        // Calculates denominator.
        const sumExps: number[] &#x3D; [];
        for (let z &#x3D; 0; z &lt; exps.length; z++) {
            const sum &#x3D; exps[z].reduce((a, b) &#x3D;&gt; a + b, 0);
            sumExps.push(sum);
        }
        // Probabilities.
        for (let z &#x3D; 0; z &lt; exps.length; z++) {
            shortestPathsProbabilities[z] &#x3D; [];
            for (let n &#x3D; 0; n &lt; exps[z].length; n++) {
                const p &#x3D; sumExps[z] &gt; 0 ? round(exps[z][n] / sumExps[z], 3) : 0;
                shortestPathsProbabilities[z].push(p);
            }
        }
        return shortestPathsProbabilities;
    }

    private calcPathCosts(odPairs: OdPair[]): number[][] {
        const pathCosts: number[][] &#x3D; [];
        for (let z &#x3D; 0; z &lt; this.shortestPaths.length; z++) {
            pathCosts[z] &#x3D; [];
            for (let n &#x3D; 0; n &lt; this.shortestPaths[z].length; n++) {
                let pathCost &#x3D; 0;
                for (let m &#x3D; 0; m &lt; this.shortestPaths[z][n].length; m++) {
                    pathCost +&#x3D; this.shortestPaths[z][n][m][odPairs[z].pathType];
                }
                pathCosts[z].push(pathCost);
            }
        }
        return pathCosts;
    }

}
</code></pre>
    </div>
</div>






                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'OdPair.html';
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
